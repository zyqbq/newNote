glb 比 gltf 小一些

gltf 可以将贴图信息整合到 glb 中

### gltf 导出插件

![image-20230724174645312](../../assests/image-20230724174645312.png)

### 场景加载 gltf

```js
// 引入gltf模型加载库GLTFLoader.js
import { GLTFLoader } from "three/addons/loaders/GLTFLoader.js";

//创建一个GLTF加载器
const loader = new GLTFLoader();

//声明一个组对象，用来添加加载成功的三维场景
const model = new THREE.Group();

loader.load("../../工厂.gltf", function (gltf) {
  //gltf加载成功后返回一个对象
  // console.log('控制台查看gltf对象结构', gltf);
  // console.log('场景3D模型数据', gltf.scene);
  model.add(gltf.scene); //三维场景添加到model组对象中
});
```

### 场景相机

200m 的场景，相机设置 200

```js
camera.position.set(200, 200, 200); //根据渲染范围尺寸数量级设置相机位置
camera.lookAt(0, 0, 0);
```

控件的 target 要同步更新，保持一致

![image-20230724180422699](../../assests/image-20230724180422699.png)

### 纹理贴图颜色偏差

和 blender 的编码方式一致

```js
//解决加载gltf格式模型颜色偏差问题
renderer.outputEncoding = THREE.sRGBEncoding;
```

### 相机控件辅助调试相机参数

```js
// 渲染循环
function render() {
  // 渲染循环中不停地打印相机的位置属性，你可以通过相机控件旋转或缩放三维场景，同时通过浏览器控制台观察相机位置变化。
  console.log("camera.position", camera.position);
  // 浏览器控制台查看controls.target变化，辅助设置lookAt参数
  console.log("controls.target", controls.target);
  renderer.render(scene, camera);
  requestAnimationFrame(render);
}
```

保持 camera 和相机控件的一致

```js
camera.lookAt(0, 0, 0);

controls.target.set(x, y, z); //与lookAt参数保持一致
controls.update(); //update()函数内会执行camera.lookAt(controls.target)
```

### 加载 glb 文件

和 gltf 加载器一样

```js
// 单独.glb文件
loader.load("../../工厂.glb", function (gltf) {
  model.add(gltf.scene);
});
```

### 批量修改组对象的网格模型的颜色

```js
//获得所有'洋房'房子的父对象
const obj = gltf.scene.getObjectByName("洋房");
console.log("obj", obj); //控制台查看返回结果
console.log("obj.children", obj.children);
// obj的所有子对象.children都是Mesh，改变Mesh对应颜色
obj.children.forEach(function (mesh) {
  mesh.material.color.set(0xffff00);
});
```

### traverse 改变所有网格模型的材质

```js
loader.load("../../工厂.glb", function (gltf) {
  // 递归遍历所有模型节点批量修改材质
  gltf.scene.traverse(function (obj) {
    if (obj.isMesh) {
      //判断是否是网格模型
      // 重新设置材质
      obj.material = new THREE.MeshLambertMaterial({
        color: 0xffffff,
      });
    }
  });
  model.add(gltf.scene);
});
```

### gltf 材质

默认是 MeshStandardMaterial 或 MeshPhysicalMaterial

### 解决多个 mesh 材质共享问题

![image-20230724185609399](../../assests/image-20230724185609399.png)

### 贴图偏色问题 8.9

纹理. encoding 和渲染器. outputEncoding 保持一致

![image-20230724185943623](../../assests/image-20230724185943623.png)

```js
THREE.LinearEncoding; //贴图中默认值 3000 渲染器的默认值
THREE.sRGBEncoding; //3001 gltf中的贴图的.encoding默认
```

纹理. encoding 和渲染器. outputEncoding
如果没有特殊需要，一般为了正常渲染，避免颜色偏差，threejs 代码中需要颜色贴图. encoding 和渲染器. outputEncoding 属性值保持一致。

```js
texture.encoding = THREE.sRGBEncoding;
renderer.outputEncoding = THREE.sRGBEncoding;
```

### texture 的.flipY

gltf 的.flipY 默认是 false

texture 的.flipY 默认是 true
