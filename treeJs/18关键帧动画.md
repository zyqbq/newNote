### 关键帧动画

```javascript
1.创建关键帧
// 给需要设置关键帧动画的模型命名
mesh.name = "Box";
const times = [0, 3, 6]; //时间轴上，设置三个时刻0、3、6秒
// times中三个不同时间点，物体分别对应values中的三个xyz坐标
const values = [0, 0, 0, 100, 0, 0, 0, 0, 100];
// 0~3秒，物体从(0,0,0)逐渐移动到(100,0,0),3~6秒逐渐从(100,0,0)移动到(0,0,100)
const posKF = new THREE.KeyframeTrack('Box.position', times, values);
// 从2秒到5秒，物体从红色逐渐变化为蓝色
//KeyframeTrack v1属性 v2时间 v3数据
const colorKF = new THREE.KeyframeTrack('Box.material.color', [2, 5], [1, 0, 0, 0, 0, 1]);

2.创建关键帧动画
// 1.3 基于关键帧数据，创建一个clip关键帧动画对象，命名"test"，持续时间6秒，所有的关键帧
const clip = new THREE.AnimationClip("test", 6, [posKF, colorKF]);

3.播放
//包含关键帧动画的模型对象作为AnimationMixer的参数创建一个播放器mixer
const mixer = new THREE.AnimationMixer(mesh);
//AnimationMixer的`.clipAction()`返回一个AnimationAction对象，放入要播放的关键帧动画
const clipAction = mixer.clipAction(clip); 
//.play()控制动画播放，默认循环播放
clipAction.play(); 


//不循环播放,执行一次后默认回到动画开头
clipAction.loop = THREE.LoopOnce; 
// 物体状态停留在动画结束的时候
clipAction.clampWhenFinished = true;

//动画停止结束，回到开始状态
clipAction.stop();

//切换为播放状态
clipAction.paused = false;
//切换为暂停状态
clipAction.paused = true;

//倍数播放
clipAction.timeScale = 1;//默认
clipAction.timeScale = 2;//2倍速

const gui = new GUI(); //创建GUI对象
// 0~6倍速之间调节
gui.add(clipAction, 'timeScale', 0, 6);

4.更新播放时间
const clock = new THREE.Clock();
function loop() {
    requestAnimationFrame(loop);
    //clock.getDelta()方法获得loop()两次执行时间间隔
    const frameT = clock.getDelta();
    // 更新播放器相关的时间
    mixer.update(frameT); 
}
loop();
```

暂停按钮逻辑

```javascript
if (clipAction.paused) {//暂停状态
        clipAction.paused = false;//切换为播放状态
        bu.innerHTML='暂停';// 如果改变为播放状态，按钮文字设置为“暂停”
      } else {//播放状态
        clipAction.paused = true;//切换为暂停状态
        bu.innerHTML='继续';// 如果改变为暂停状态，按钮文字设置为“继续”
      }
```

##### 选择时间段播放1s-5s

```js
配合下方的播放时间段使用
//不循环播放
clipAction.loop = THREE.LoopOnce; 
// 物体状态停留在动画结束的时候
clipAction.clampWhenFinished=true;

//AnimationAction设置开始播放时间：从1秒时刻对应动画开始播放
clipAction.time = 1; 
//AnimationClip设置播放结束时间：到5秒时刻对应的动画状态停止
clip.duration = 5;
```

###  查看时间轴上任意时间动画状态

```javascript
//在暂停情况下，设置.time属性,把动画定位在任意时刻
clipAction.paused = true;
clipAction.time = 1;//物体状态为动画1秒对应状态
clipAction.time = 3;//物体状态为动画3秒对应状态
```

### 拖动条拖动显示动画任意时刻模型状态

```javascript
import {GUI} from 'three/addons/libs/lil-gui.module.min.js';
const gui = new GUI(); //创建GUI对象
gui.add(clipAction, 'time', 0, 6);
```

###  动画下一步状态

```javascript
const bu = document.getElementById('bu');
bu.addEventListener('click', function () {
  clipAction.time += 0.1; 
})
```

### 解析外部模型关键帧动画

查看gltf模型动画数据

gltf.animations是一个数组，里面放着关键帧动画

```javascript
loader.load("../工厂.glb", function (gltf) { 
    console.log('控制台查看gltf对象结构', gltf);
    // console.log('动画数据', gltf.animations);
    model.add(gltf.scene); 

    //包含关键帧动画的模型作为参数创建一个播放器
    可以放入包含动画的父对象
    const mixer = new THREE.AnimationMixer(gltf.scene);
    //  获取gltf.animations[0]的第一个clip动画对象
    const clipAction = mixer.clipAction(gltf.animations[0]); //创建动画clipAction对象
    clipAction.play(); //播放动画
    //不循环播放 默认是循环播放
clipAction.loop = THREE.LoopOnce; 
// 物体状态停留在动画结束的时候
clipAction.clampWhenFinished = true

    // 如果想播放动画,需要周期性执行`mixer.update()`更新AnimationMixer时间数据
    const clock = new THREE.Clock();
    function loop() {
        requestAnimationFrame(loop);
        //clock.getDelta()方法获得loop()两次执行时间间隔
        const frameT = clock.getDelta();
        // 更新播放器相关的时间
        mixer.update(frameT);
    }
    loop();
})
```

### 刚播放就处于暂停

```javascript
const clipAction = mixer.clipAction(clip); //创建动画clipAction对象
clipAction.play(); //播放动画
clipAction.paused = true; //暂停状态
```

### 播放完成设置按钮为播放

clipAction.reset()重置动画为初始状态

```javascript
clipAction.loop = THREE.LoopOnce; 
// 动画播放完成事件
mixer.addEventListener('finished', function () {
    bu.innerHTML = '播放';//播放完成，按钮显示为“播放”
    clipAction.reset(); //重新开始新的动画播放
    clipAction.paused = true; //切换为暂停状态
});
```

### 变形动画

```js
设置几何体变形目标顶点数据// 几何体顶点变形目标数据，可以设置1组或多组
geometry是目标模型 target1是要变形的顶点坐标
geometry.morphAttributes.position = [target1, target2];

模型向该几何体变形的系数，0-1，越接近1影响越大
mesh.morphTargetInfluences是一个数组，包含所有的变形内容
mesh.morphTargetInfluences[0]=0
```



```javascript
//几何体两组顶点一一对应，位置不同，然后通过权重系数，可以控制模型形状在两组顶点之间变化
const geometry = new THREE.BoxGeometry(50, 50, 50);
// 为geometry提供变形目标的顶点数据(注意和原始geometry顶点数量一致)
const target1 = new THREE.BoxGeometry(50, 200, 50).attributes.position;//变高
const target2 = new THREE.BoxGeometry(10, 50, 10).attributes.position;//变细
// 几何体顶点变形目标数据，可以设置1组或多组
geometry.morphAttributes.position = [target1, target2];

const mesh = new THREE.Mesh(geometry, material);
//权重0：物体形状对应geometry.attributes.position表示形状
mesh.morphTargetInfluences[0] = 0.0;
//权重1：物体形状对应target1表示形状
mesh.morphTargetInfluences[0] = 1.0;
//权重0.5：物体形状对应geometry和target1变形中间状态
mesh.morphTargetInfluences[0] = 0.5;
```

关键帧配合变形

最终权重系数都会变为1

```javascript
// 创建变形动画权重系数的关键帧数据
mesh.name = "Box";//关键帧动画控制的模型对象命名
// 设置变形目标1对应权重随着时间的变化
const KF1 = new THREE.KeyframeTrack('Box.morphTargetInfluences[0]', [0, 5], [0, 1]);
// 设置变形目标2对应权重随着时间的变化
const KF2 = new THREE.KeyframeTrack('Box.morphTargetInfluences[1]', [5, 10], [0, 1]);
// 创建一个剪辑clip对象
const clip = new THREE.AnimationClip("t", 10, [KF1, KF2]);

// 播放变形动画
const mixer = new THREE.AnimationMixer(mesh);
const clipAction = mixer.clipAction(clip);
clipAction.play();
clipAction.loop = THREE.LoopOnce; //不循环播放
clipAction.clampWhenFinished = true // 物体状态停留在动画结束的时候

const clock = new THREE.Clock();

function loop() {
    requestAnimationFrame(loop);
    const frameT = clock.getDelta();
    // 更新播放器时间
    mixer.update(frameT);
}
loop();
```

gltf文件变形动画，和普通gltf关键帧动画一样

```javascript
loader.load("./鸟.glb", function (gltf) { 
    model.add(gltf.scene); 

    //包含关键帧动画的模型作为参数创建一个播放器
    const mixer = new THREE.AnimationMixer(gltf.scene);
    //  获取gltf.animations[0]的第一个clip动画对象
    const clipAction = mixer.clipAction(gltf.animations[0]);
    clipAction.play();

    const clock = new THREE.Clock();
    function loop() {
        requestAnimationFrame(loop);
        const frameT = clock.getDelta();
        // 更新播放器相关的时间
        mixer.update(frameT);
    }
    loop();
})
```

### 骨骼动画

```javascript
const Bone1 = new THREE.Bone(); //关节1，用来作为根关节
const Bone2 = new THREE.Bone(); //关节2
const Bone3 = new THREE.Bone(); //关节3

// 设置关节父子关系   多个骨头关节构成一个树结构
Bone1.add(Bone2);
Bone2.add(Bone3);

//根关节Bone1默认位置是(0,0,0)
Bone2.position.y = 60; //Bone2相对父对象Bone1位置
Bone3.position.y = 30; //Bone3相对父对象Bone2位置
//平移Bone1，Bone2、Bone3跟着平移
Bone1.position.set(50,0,50);

// 骨骼关节可以和普通网格模型一样作为其他模型子对象，添加到场景中
const group = new THREE.Group();
group.add(Bone1);

// SkeletonHelper会可视化参数模型对象所包含的所有骨骼关节
const skeletonHelper = new THREE.SkeletonHelper(group);
group.add(skeletonHelper);

// 骨骼关节旋转
Bone1.rotateX(Math.PI / 6);
Bone2.rotateX(Math.PI / 6);
```

### 加载外部模型骨骼

```javascript
const loader = new GLTFLoader(); 
loader.load("../骨骼动画.glb", function (gltf) {
    console.log('控制台查看gltf对象结构', gltf);
    model.add(gltf.scene);
    // 骨骼辅助显示
    const skeletonHelper = new THREE.SkeletonHelper(gltf.scene);
    model.add(skeletonHelper); 
    
    // 根据骨骼关节名字获取骨关节Bone  
// 在三维软件中，骨骼关节层层展开，可以看到下面三个骨骼关节
const bone1 = gltf.scene.getObjectByName('Bone1'); //关节1
const bone2 = gltf.scene.getObjectByName('Bone2'); //关节2
const bone3 = gltf.scene.getObjectByName('Bone3'); //关节3
    
    bone2.rotation.x = Math.PI / 6; //关节2旋转
bone3.rotation.x = Math.PI / 6; //关节3旋转
})
```

### 查看骨骼网格模型

```javascript
const loader = new GLTFLoader(); 
loader.load("../骨骼动画.glb", function (gltf) {
    console.log('控制台查看gltf对象结构', gltf);
    model.add(gltf.scene);
    // 根据节点名字获取某个骨骼网格模型
    const SkinnedMesh = gltf.scene.getObjectByName('身体');
    console.log('骨骼网格模型', SkinnedMesh);
})
```

### 骨骼网格模型的骨架

SkinnedMesh.skeleton骨架

SkinnedMesh.skeleton.bones关节组成的数组

第一个是根关节

```js
// 根据节点名字获取某个骨骼网格模型
const SkinnedMesh = gltf.scene.getObjectByName('身体');
console.log('骨架', SkinnedMesh.skeleton);
console.log('骨架所有关节', SkinnedMesh.skeleton.bones);
console.log('根关节', SkinnedMesh.skeleton.bones[0]);
```

### 走跑停 状态转换

```javascript
const IdleAction = mixer.clipAction(gltf.animations[0]);
const RunAction = mixer.clipAction(gltf.animations[1]);
const WalkAction = mixer.clipAction(gltf.animations[3]);
IdleAction.play();
let ActionState = IdleAction;//当前处于播放状态的动画动作对象
// 通过UI按钮控制，切换动画运动状态
document.getElementById('Idle').addEventListener('click', function () {
    ActionState.stop();//播放状态动画终止
    IdleAction.play();
    ActionState = IdleAction;
})
document.getElementById('Run').addEventListener('click', function () {
    ActionState.stop();//播放状态动画终止
    RunAction.play();
    ActionState = RunAction;
})
document.getElementById('Walk').addEventListener('click', function () {
    ActionState.stop();//播放状态动画终止
    WalkAction.play();
    ActionState = WalkAction;
  })
```

### 动画权重

`.weight`可以控制动画的执行，权重为0，对应动画不影响人的动作，权重为1影响程度最大。

```javascript
const IdleAction = mixer.clipAction(gltf.animations[0]);
const RunAction = mixer.clipAction(gltf.animations[1]);
const WalkAction = mixer.clipAction(gltf.animations[3]);
IdleAction.play();
RunAction.play();
WalkAction.play();
```