### 后期处理

就像ps一样，对threejs的渲染结果进行后期处理，比如添加发光效果。

threejs文件包目录`examples/jsm/postprocessing/`可以看到threejs提供了很多后处理通道

- `OutlinePass.js`：高亮发光描边
- `UnrealBloomPass.js`：Bloom发光
- `GlitchPass.js`：画面抖动效果

### OutlinePass.js

`OutlinePass`可以给指定的某个模型对象添加一个高亮发光描边效果

![img](http://www.webgl3d.cn/imgthreejs/%E9%AB%98%E4%BA%AE%E5%8F%91%E5%85%89%E6%8F%8F%E8%BE%B9.jpg)



```javascript
1.引入`EffectComposer.js`  效果合成器
import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';

// 创建后处理对象EffectComposer，WebGL渲染器作为参数
const composer = new EffectComposer(renderer);

2.引入渲染器通道RenderPass 指明要处理的场景和相机
import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
// 创建一个渲染器通道，场景和相机作为参数
const renderPass = new RenderPass(scene, camera);
// 给EffectComposer添加一个渲染器通道RenderPass
composer.addPass(renderPass);

3.引入OutlinePass通道
import { OutlinePass } from 'three/addons/postprocessing/OutlinePass.js';
// OutlinePass第一个参数二维向量的尺寸和canvas画布保持一致
const v2 = new THREE.Vector2(window.innerWidth, window.innerWidth);
// const v2 = new THREE.Vector2(800, 600);
const outlinePass = new OutlinePass(v2, scene, camera);

4.指定要发光的网格模型
outlinePass.selectedObjects = [mesh];
// 多个模型对象
outlinePass.selectedObjects = [mesh1,mesh2,group];

4.1outlinePass描边样式
//模型描边颜色，默认白色         
outlinePass.visibleEdgeColor.set(0xffff00); 
//描边厚度 默认1
outlinePass.edgeThickness = 4; 
//描边亮度 默认3
outlinePass.edgeStrength = 6; 
 //模型闪烁频率控制，默认0不闪烁  1最快
outlinePass.pulsePeriod = 2;

5.将outlinepass添加到后处理效果合成器中
composer.addPass(outlinePass)

6.循环调用渲染器 
function render() {
    //效果合成器会调用渲染器
    composer.render();
   // renderer.render(scene, camera)不用再执行。
    // renderer.render(scene, camera);
    requestAnimationFrame(render);
}
render();
```

### gltf发光

```js
// 引入后处理扩展库EffectComposer.js
import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
// 引入渲染器通道RenderPass
import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
// 引入OutlinePass通道
import { OutlinePass } from 'three/addons/postprocessing/OutlinePass.js';

// 创建后处理对象EffectComposer，WebGL渲染器作为参数
const composer = new EffectComposer(renderer);
const renderPass = new RenderPass(scene, camera);
composer.addPass(renderPass);

// 创建OutlinePass通道
const v2 = new THREE.Vector2(window.innerWidth, window.innerWidth);
const outlinePass = new OutlinePass(v2, scene, camera);
// outlinePass.selectedObjects = [mesh];
outlinePass.visibleEdgeColor.set(0x00ffff);
outlinePass.edgeThickness = 4;
outlinePass.edgeStrength = 6;
composer.addPass(outlinePass);

document.getElementById('A').addEventListener('click',function(){
    const A = model.getObjectByName ('设备A');
    outlinePass.selectedObjects = [A];
})
document.getElementById('B').addEventListener('click',function(){
    const B = model.getObjectByName ('设备B');
    outlinePass.selectedObjects = [B];
})

// 渲染循环
function render() {
    composer.render();
    // renderer.render(scene, camera);
    requestAnimationFrame(render);
}
render();
```

### Bloom发光通道

```js
3.// 引入UnrealBloomPass通道
import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

// canvas画布宽高度尺寸是800, 600
const bloomPass = new UnrealBloomPass(new THREE.Vector2(800, 600));
// canvas画布宽高度window.innerWidth, window.innerHeight
const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight));

//bloom发光强度 默认是1.0
bloomPass.strength = 2.0; 

// 设置bloomPass通道 
composer.addPass(bloomPass);
```

### `GlitchPass`闪屏通道

```js
1.// 引入GlitchPass通道
import { GlitchPass } from 'three/addons/postprocessing/GlitchPass.js';

const glitchPass = new GlitchPass();
// 设置glitchPass通道
composer.addPass(glitchPass);
```

### 后处理颜色偏差

后处理下面的渲染器设置会失效

```javascript
renderer.outputEncoding = THREE.sRGBEncoding;
```

```javascript
// 伽马校正后处理Shader
import {GammaCorrectionShader} from 'three/addons/shaders/GammaCorrectionShader.js';

// ShaderPass功能：使用后处理Shader创建后处理通道
import {ShaderPass} from 'three/addons/postprocessing/ShaderPass.js';

// 创建伽马校正通道
const gammaPass= new ShaderPass(GammaCorrectionShader);
composer.addPass(gammaPass);
```

## 抗锯齿

后处理就可能带来锯齿问题

### FXAA抗锯齿通道

有一点效果

```javascript
// ShaderPass功能：使用后处理Shader创建后处理通道
import {ShaderPass} from 'three/addons/postprocessing/ShaderPass.js';
// FXAA抗锯齿Shader
import { FXAAShader } from 'three/addons/shaders/FXAAShader.js';

2.设置FAXX抗锯齿通道
const FXAAPass = new ShaderPass( FXAAShader );
// `.getPixelRatio()`获取`renderer.setPixelRatio()`设置的值
const pixelRatio = renderer.getPixelRatio();//获取设备像素比 
// width、height是canva画布的宽高度
FXAAPass.uniforms.resolution.value.x = 1 /(width*pixelRatio);
FXAAPass.uniforms.resolution.value.y = 1 /(height*pixelRatio);
composer.addPass( FXAAPass );
```

### SMAA抗锯齿通道

SMAA相比较FXAA抗锯齿效果更好一些。

```javascript
// SMAA抗锯齿通道
import {SMAAPass} from 'three/addons/postprocessing/SMAAPass.js';

//获取.setPixelRatio()设置的设备像素比
const pixelRatio = renderer.getPixelRatio();
// width、height是canva画布的宽高度
const smaaPass = new SMAAPass(width * pixelRatio, height * pixelRatio);
composer.addPass(smaaPass);
```