精灵模型平行于canvas画布

### 精灵模型Sprite

精灵模型`Sprite`和Threejs的网格模型`Mesh`一样都是模型对象，父类都是`Object3D`

![img](http://www.webgl3d.cn/imgthreejs/%E7%82%B9%E7%BA%BF%E7%BD%91%E6%A0%BC%E7%B2%BE%E7%81%B5%E6%A8%A1%E5%9E%8B.png)

### 创建精灵模型材质`SpriteMaterial`

![img](http://www.webgl3d.cn/imgthreejs/%E6%9D%90%E8%B4%A8Material.png)

精灵材质对象`SpriteMaterial`和普通的网格材质一样可以设置颜色`.color`、颜色贴图`.map`、开启透明`.transparent`、透明度`.opacity`等属性

精灵材质对象`SpriteMaterial`的父类是材质`Material`。

精灵模型默认是一个矩形形状，尺寸长宽都是1

```javascript
// 创建精灵材质对象SpriteMaterial
const spriteMaterial = new THREE.SpriteMaterial({
  color:0x00ffff,//设置颜色
});
// 创建精灵模型对象，不需要几何体geometry参数
const sprite = new THREE.Sprite(spriteMaterial);
```

```javascript
// 控制精灵大小
console.log('sprite.scale',sprite.scale);
sprite.scale.set(50, 25, 1); //只需要设置x、y两个分量就可以，z不起，作用默认是1
//位置坐标
sprite.position.set(0,50,0);
```

### 贴图标注精灵模型平行于canvas画布

```javascript
const texture = new THREE.TextureLoader().load("./光点.png");
const spriteMaterial = new THREE.SpriteMaterial({
  map: texture, //设置精灵纹理贴图
});
sprite.scale.set(10, 10, 1);
sprite.position.set(0, 100 + 10/2, 0);//设置位置，要考虑sprite尺寸影响
```

### 下雨

```javascript
const texture = new THREE.TextureLoader().load("./雨滴.png");
const spriteMaterial = new THREE.SpriteMaterial({
    map: texture, 
});
const sprite = new THREE.Sprite(spriteMaterial);
```

#### 雨滴在3D空间随机分布

```javascript
const group = new THREE.Group();
for (let i = 0; i < 16000; i++) {
    // 精灵模型共享材质
    const sprite = new THREE.Sprite(spriteMaterial);
    group.add(sprite);
    sprite.scale.set(1, 1, 1);
    // 设置精灵模型位置，在长方体空间上上随机分布
    const x = 1000 * (Math.random() - 0.5);
    const y = 600 * Math.random();
    const z = 1000 * (Math.random() - 0.5);
    sprite.position.set(x, y, z)
}
```

#### 根据时间计算Sprite位置

```javascript
const clock = new THREE.Clock();
function loop() {
    // loop()两次执行时间间隔
    const t = clock.getDelta();
    group.children.forEach(sprite => {
        // 雨滴的y坐标每次减t*60
        sprite.position.y -= t*60;
        if (sprite.position.y < 0) {
            sprite.position.y = 600;
        }
    });
    requestAnimationFrame(loop);
}
loop();
```

