## 向量

有大小有方向的量（数学中）

表示方向或者位置

模型的位置用向量表示标量

- 二维向量[Vector2](http://www.yanhuangxueyuan.com/threejs/docs/index.html#api/math/Vector2)
- 三维向量[Vector3](http://www.yanhuangxueyuan.com/threejs/docs/index.html#api/math/Vector3)
- 四维向量[Vector4](http://www.yanhuangxueyuan.com/threejs/docs/index.html#api/math/Vector4)

```js
mesh.position.y = 80;// 设置网格模型y坐标
mesh.position.set(80,2,10);// 设置模型xyz坐标
```

```js
var mesh = new THREE.Mesh()
mesh.position.set(100,20,330);//设置网格模型的位置
console.log('对象位置属性',mesh.position);0,0,0
console.log('对象缩放属性',mesh.scale);//1,1,1
```

#### 向量加法

`B.addVectors(A,walk)`的含义就是向量A和向量walk的x、y、z三个分量分别相加(`B.x = A.x + walk.x;`、`B.y = A.y + walk.y;`、`B.z = A.z + walk.z;`)。赋值给B



`A.add(walk);`

A和walk的x、y、z属性分别相加，相加的结果替换A原来的x、y、z。

```javascript
const A = new THREE.Vector3(30, 30, 0);// 人起点A
// walk表示运动的位移量用向量
const walk = new THREE.Vector3(100, 50, 0);
const B = new THREE.Vector3();// 人运动结束点B
// addVectors的含义就是参数中两个向量xyz三个分量分别相加
B.addVectors(A,walk);//A向量加walk向量，赋值给B
console.log('B',B);
```

#### 复制`.copy()`

B.copy(A)改变B的值为A

```javascript
// 两个小球网格模型可视化A点和B点
mesh1.position.copy(A);//将mesh1的坐标设置为A
mesh2.position.copy(B);
```

#### 克隆

B和A一样，但是是新值

```javascript
const B = A.clone()
```

#### 速度

![img](http://www.webgl3d.cn/imgthreejs/%E5%90%91%E9%87%8F%E8%A1%A8%E7%A4%BA%E9%80%9F%E5%BA%A6.jpg)

假设一个人的运动速度大小是√2,方向是x和y正半轴的角平分线，那么人的速度可以用向量`THREE.Vector3(1, 1, 0)`表示。

#### 路径距离

v.multiplyScalar(50);向量v和标量50的乘法

```javascript
// `.multiplyScalar(50)`表示向量x、y、z三个分量和参数分别相乘
v表示速度向量
const v = new THREE.Vector3(1, 1, 0);
const walk = v.clone().multiplyScalar(50);
// 运动50秒结束位置B
const B = A.clone().add(walk);
```

#### 向量减法

b-a=ab ab是由a到b的向量

`AB.subVectors(B,A);`的含义表示B的xyz三个分量，与A的xyz三个分量分别相减，然后赋值给向量AB。

```javascript
const A = new THREE.Vector3(30, 30, 0);
const B = new THREE.Vector3(130,80,0);
const AB = new THREE.Vector3();
AB.subVectors(B,A);
```

`B.sub(A);`表示B的xyz三个属性分别减去A的xyz三个属性，然后结果赋值给B自身的xyz属性

```javascript
B.sub(A);
console.log('B',B);
```

如果希望基于A和B两点位置，生成一个A指向B的向量，可以B克隆一个新对象，减去A。(如果B不克隆，B本身会被改变)

```javascript
const AB = B.clone().sub(A);
console.log('AB',AB);
```

### 向量AB物理含义

向量AB包含了两层信息，一个是从A移动到B点的位移方向，另一层信息是AB两点的距离，你可以把AB两点之间的距离称为向量长度(大小)

### 向量长度.length()

```javascript
计算ab的距离
const A = new THREE.Vector3(30,30,0);// 人起点A
const B = new THREE.Vector3(130,80,0);// 人运动结束点B
const AB = B.clone().sub(A);
const L = AB.length();
```

### 向量归一化

```javascript
const dir = new THREE.Vector3(1, 1, 0);
dir.normalize(); //向量归一化 改变dir的值
```

#### 物体沿着直线AB方向平移

```javascript
//直线上两点坐标A和B
const A = new THREE.Vector3(-50,0,-50);
const B = new THREE.Vector3(100,0,100);
const AB = B.clone().sub(A);//AB向量
AB.normalize();//AB归一化表示直线AB的方向

//T表示沿ab平移100
const T =  AB.clone().multiplyScalar(100);
//物体沿向量方向平移
mesh.position.add(T);

//沿着AB方向平移100 AB为单位向量
mesh.translateOnAxis(AB, 100);
```

#### 相机沿物体方向靠近

向量 a指向b就是b-a

```javascript
camera.position.set(202, 123, 125);
camera.lookAt(0, 0, 0);
// 相机目标观察点和相机位置相减,获得一个沿着相机视线方向的向量
const dir = new THREE.Vector3(0 - 202,0 - 123,0 - 125);
// 归一化,获取一个表示相机视线方向的单位向量。
dir.normalize();
```

##### 获取相机视线方向`camera.getWorldDirection()`

快速获取一个沿着相机视线方向的单位向量

```javascript
const dir = new THREE.Vector3();
// 获取相机的视线方向
camera.getWorldDirection(dir);//赋值给dir dir是单位向量
```

相机沿某个方向移动

```javascript
// dis向量表示相机沿着相机视线方向平移200的位移量
const dis = dir.clone().multiplyScalar(200);
// 相机沿着视线方向平移
camera.position.add(dis);
```

动画

```javascript
const dir = new THREE.Vector3();
camera.getWorldDirection(dir);// 获取相机的视线方向
// dis表示相机沿着相机视线方向平移200
const dis = dir.clone().multiplyScalar(200);
// 相机动画:平移前坐标——>平移后坐标
camera.position要改变的属性对象{x：y: z: }
new TWEEN.Tween(camera.position)
.to(camera.position.clone().add(dis), 3000)
.start()

function render() {
    TWEEN.update();
    renderer.render(scene, camera);
    requestAnimationFrame(render);
}
render();
```

### 箭头ArrowHelper可视化向量

v1方向

v2箭头起点

v3长度

```javascript
// 绘制一个从A指向B的箭头
const AB = B.clone().sub(A);
const L = AB.length();//AB长度
const dir = AB.clone().normalize();//单位向量表示AB方向

// 生成箭头从A指向B
const arrowHelper = new THREE.ArrowHelper(dir, A, L)
group.add(arrowHelper);
```

### 弧度

`Math.PI`表示180度对应的弧度值

```javascript
const angle = Math.PI/6;//30度
const angle = Math.PI/2;//90度
const angle = Math.PI;//180度
```

```javascript
// 弧度转度
const angle = THREE.MathUtils.radToDeg(Math.PI);
console.log('Math.PI',angle);//180
```

```javascript
// 度转弧度
const angle = THREE.MathUtils.degToRad(30);//Math.PI/6
```

### JavaScript三角函数

JavaScript语言`Math`对象提供了多个用于三角函数计算的方法。

| 方法                               | 含义     |
| ---------------------------------- | -------- |
| `Math.sin`(弧度)=对比/斜边 计算y轴 | 正弦值   |
| `Math.cos`(弧度)=邻比/斜边 计算x轴 | 余弦值   |
| `Math.tan`(弧度)                   | 正切值   |
| `Math.asin`(正弦值)                | 反正弦值 |
| `Math.acos`(余弦值)                | 反余弦值 |

  

![img](http://www.webgl3d.cn/imgthreejs/%E4%B8%89%E8%A7%92%E5%87%BD%E6%95%B0%E8%AE%A1%E7%AE%97%E7%82%B9%E5%9D%90%E6%A0%87xy.jpg)

### 物体匀速运动

```javascript
const v = new THREE.Vector3(10,0,10);//物体运动速度
const clock = new THREE.Clock();//时钟对象
// 渲染循环
function render() {
    const spt = clock.getDelta();//两帧渲染时间间隔(秒)
    // 在spt时间内，以速度v运动的位移量
    const dis = v.clone().multiplyScalar(spt);
    // 网格模型当前的位置加上spt时间段内运动的位移量
    mesh.position.add(dis);
    renderer.render(scene, camera);
    requestAnimationFrame(render);
}
render();
```

###  物体下落动画(重力加速度) 

![image-20230806093915187](../../../assests/image-20230806093915187.png)

```javascript
const v = new THREE.Vector3(30, 0, 0);//物体运动速度
const clock = new THREE.Clock();//时钟对象
let t = 0;
const g = new THREE.Vector3(0, -9.8, 0);
const pos0 = mesh.position.clone();
// 渲染循环
function render() {
    const spt = clock.getDelta();//两帧渲染时间间隔(秒)
    t += spt;
    // 在t时间内，以速度v运动的位移量
    const dis = v.clone().multiplyScalar(t).add(g.clone().multiplyScalar(0.5 * t * t));
    // 网格模型当前的位置加上spt时间段内运动的位移量
    const newPos = pos0.clone().add(dis);
    mesh.position.copy(newPos);
    renderer.render(scene, camera);
    requestAnimationFrame(render);
}
render();
```

### 向量点乘dot

![image-20231018180415785](img/image-20231018180415785.png)

计算夹角余弦值

![image-20231018180600698](img/image-20231018180600698.png)

归一化会改变原变量

改写

![image-20231018181346203](img/image-20231018181346203.png)

求得夹角角度

![image-20231018181606704](img/image-20231018181606704.png)

#### 计算三角形夹角

![image-20231018182015696](img/image-20231018182015696.png)

### 矩阵

![image-20230807231055042](../../../assests/image-20230807231055042.png)

![image-20230807231250591](../../../assests/image-20230807231250591.png)

### 平移矩阵 

![image-20230807231454004](../../../assests/image-20230807231454004.png)

###  缩放矩阵

![img](http://www.webgl3d.cn/imgwegpu/%E7%BC%A9%E6%94%BE%E7%9F%A9%E9%98%B5%E9%AA%8C%E8%AF%81%E8%AE%A1%E7%AE%97.jpg)

###  旋转矩阵                                                                                                                  

![img](http://www.webgl3d.cn/imgwegpu/%E7%BB%95z%E8%BD%B4%E6%97%8B%E8%BD%AC%E7%9F%A9%E9%98%B5.jpg)

假设一个点的坐标是(x,y,z),经过旋转变换后的坐标为(X,Y,Z)

**绕Z轴旋转γ角度**,z的坐标不变不变，x、y的坐标发生变化，如果你有兴趣，可以用你高中的三角函数知识推理，可以知道旋转后的坐标：X=xcosγ-ysinγ,Y=xsinγ+ycosγ

![img](http://www.webgl3d.cn/imgwegpu/%E7%BB%95%E7%9D%80z%E8%BD%B4%E6%97%8B%E8%BD%AC%E5%90%8E%E5%9D%90%E6%A0%87%E8%AE%A1%E7%AE%97.jpg)

三角函数计算推理过程

```js
// 假设旋转前角度A，对应x和y的值
x = R * cos(A)
y = R * sin(A)

// 假设旋转了γ度，对应X和Y的值
X = R * cos(γ+A)
  = R * (cos(γ)cos(A)-sin(γ)sin(A))
  = R*cos(A)cos(γ) - R*sin(A)sin(γ)
  = xcosγ-ysinγ

Y = R * sin(γ+A)
  = R * (sin(γ)cos(A)+cos(γ)sin(A))
  = R*cos(A)sin(γ) + R*sin(A)cos(γ)
  = xsinγ+ycosγ
```

### 模型矩阵

平移缩放矩阵相乘

![image-20230807233415012](../../../assests/image-20230807233415012.png)

顺序：先发生的向后放

###  单位矩阵

单位矩阵就是对角线上都为1，其它为0的矩阵。

![img](http://www.webgl3d.cn/imgwegpu/%E5%8D%95%E4%BD%8D%E7%9F%A9%E9%98%B5.jpg)

单位矩阵乘任何矩阵没有变化

### threejs中的矩阵

```javascript
// 创建一个4x4矩阵对象
const mat4 = new THREE.Matrix4()

// 平移矩阵，沿着x轴平移50
// 1, 0, 0, x,
// 0, 1, 0, y,
// 0, 0, 1, z,
// 0, 0, 0, 1
const mat4 = new THREE.Matrix4()
//列优先排列mat4.elements默认是单位矩阵
mat4.elements=[1,0,0,0, 0,1,0,0, 0,0,1,0,  50, 0, 0, 1];
```

顶点几何变换

p.applyMatrix4(mat4);向量乘矩阵 p为position坐标

```javascript
// 空间中p点坐标
const p = new THREE.Vector3(50,0,0);
// 矩阵对p点坐标进行平移变换
p.applyMatrix4(mat4);
console.log('查看平移后p点坐标',p);
```

### threejs的封装创建变化矩阵

- 平移矩阵`.makeTranslation(Tx,Ty,Tz)`
- 缩放矩阵`.makeScale(Sx,Sy,Sz)`
- 绕x轴的旋转矩阵`.makeRotationX(angleX)`
- 绕y轴的旋转矩阵`.makeRotationY(angleY)`
- 绕z轴的旋转矩阵`.makeRotationZ(angleZ)`

```javascript
const mat4 = new THREE.Matrix4();
// 生成平移矩阵(沿着x轴平移50)
mat4.makeTranslation(50,0,0);
// 结果和.elements=[1,0,0,0,...... 50, 0, 0, 1]一样
console.log('查看矩阵的值',mat4.elements);
```

平移矩阵案例

```javascript
const mat4 = new THREE.Matrix4();
// 生成平移矩阵(沿着x轴平移50)
// mat4.makeTranslation(50,0,0);
console.log('查看矩阵的值',mat4.elements);
```

旋转矩阵案例

```javascript
const mat4 = new THREE.Matrix4();
//生成绕z轴旋转90度的矩阵
mat4.makeRotationZ(Math.PI/2);
```

### 复合矩阵

```javascript
// 空间中p点坐标
const p = new THREE.Vector3(50,0,0);

const T = new THREE.Matrix4();
T.makeTranslation(50,0,0);//平移矩阵
const R = new THREE.Matrix4();
R.makeRotationZ(Math.PI/2);//旋转矩阵
// p点矩阵变换
p.applyMatrix4(T);//先平移
p.applyMatrix4(R);//后旋转

mesh.position.copy(p);//用小球可视化p点位置
```

### `.multiply()`矩阵乘法

先变换的放(中)，放后面

```javascript
const T = new THREE.Matrix4();
T.makeTranslation(50,0,0);//平移矩阵
const R = new THREE.Matrix4();
R.makeRotationZ(Math.PI/2);//旋转矩阵

// 旋转矩阵和平移矩阵相乘得到一个复合模型矩阵
 
const modelMatrix = R.clone().multiply(T);
p.applyMatrix4(modelMatrix);
```

## 本地矩阵和世界矩阵

### 本地矩阵`.matrix`和世界矩阵`.matrixWorld`

一个mesh的世界矩阵等于本地矩阵和父对象世界矩阵的乘积

### 本地坐标和世界坐标

自身的position和父对象世界坐标之和

### `.updateMatrixWorld()`

执行updateMatrixWorld()方法，模型的本地矩阵和世界属性都会更新

如果模型有子对象，子对象点到矩阵模型也会更新

```javascript
mesh.updateMatrixWorld();
console.log('本地矩阵',mesh.matrix);
console.log('世界矩阵',mesh.matrixWorld);
```

### `.render()`

也会更新本地矩阵和世界矩阵

### 相机视图矩阵

![image-20230808102017627](../../../assests/image-20230808102017627.png)

![image-20230808102043530](../../../assests/image-20230808102043530.png)

### .[updateProjectionMatrix](https://threejs.org/docs/index.html#api/zh/cameras/PerspectiveCamera.updateProjectionMatrix) ()

更新摄像机投影矩阵。在任何参数被改变以后必须被调用

改变了参数就必须更新，如画布尺寸变化了