### 射线 Ray

一条线把一个点作为**起点**，然后沿着某个**方向**无限延伸

```js
// 创建射线对象Ray
const ray = new THREE.Ray();

// 设置射线起点
ray.origin = new THREE.Vector3(1, 0, 3);
// 设置射线起点
ray.origin.set(1, 0, 3);

方向向量长度保证为1;
// 表示射线沿着x轴正方向
ray.direction = new THREE.Vector3(1, 0, 0);
// 表示射线沿着x轴负方向
ray.direction = new THREE.Vector3(-1, 0, 0);
//.normalize()归一化
ray.direction = new THREE.Vector3(5, 0, 0).normalize();
```

#### `.intersectTriangle()`方法

能够计算是否和一个三角形交叉

```javascript
// 三角形三个点坐标
const p1 = new THREE.Vector3(100, 25, 0);
const p2 = new THREE.Vector3(100, -25, 25);
const p3 = new THREE.Vector3(100, -25, -25);

//用来记录射线和三角形的交叉点
const point = new THREE.Vector3();
// `.intersectTriangle()`计算射线和三角形是否相交叉，相交返回交点，不相交返回null
false 是否正面剔除 两个方向穿过都行
const result = ray.intersectTriangle(p1,p2,p3,false,point);

result和point都是结果
console.log('交叉点坐标', point);point不交叉值还是0,0,0
console.log('查看是否相交', result);result 不相交返回null
```

### Raycaster(射线拾取模型)

模型先射中的放在 intersects 数组的前面

```javascript
const raycaster = new THREE.Raycaster();
console.log("射线属性", raycaster.ray);
// 设置射线起点
raycaster.ray.origin = new THREE.Vector3(-100, 0, 0);
// 设置射线方向射线方向沿着x轴
raycaster.ray.direction = new THREE.Vector3(1, 0, 0);
```

```javascript
// 射线发射拾取模型对象
const intersects = raycaster.intersectObjects([mesh1, mesh2, mesh3]);
console.log("射线器返回的对象", intersects);

// intersects.length大于0说明，说明选中了模型
if (intersects.length > 0) {
  console.log("交叉点坐标", intersects[0].point);
  //网格模型
  console.log("交叉对象", intersects[0].object);
  //原点到交叉点的距离
  console.log("射线原点和交叉点距离", intersects[0].distance);
}
```

### offset 和 client 区别

offset 是dom元素相对的坐标

client 以浏览器左上角为参考

![image-20230730184850860](../../assests/image-20230730184850860.png)

```javascript
addEventListener("click", function (event) {
  const cx = event.clientX;
  const cy = event.clientY;
});
```

### 标准设备坐标系

![img](http://www.webgl3d.cn/imgthreejs/WebGL%E6%A0%87%E5%87%86%E8%AE%BE%E5%A4%87%E5%9D%90%E6%A0%87.JPG)

```javascript
// 坐标转化公式
addEventListener("click", function (event) {
  const px = event.offsetX;
  const py = event.offsetY;
  //屏幕坐标px、py转标准设备坐标x、y
  //width、height表示canvas画布宽高度
  const x = (px / width) * 2 - 1;
  const y = -(py / height) * 2 + 1;
});

//client屏幕坐标转标准设备坐标
addEventListener("click", function (event) {
  // left、top表示canvas画布布局，距离顶部和左侧的距离(px)
  const px = event.clientX - left;
  const py = event.clientY - top;
  //屏幕坐标px、py转标准设备坐标x、y
  //width、height表示canvas画布宽高度
  const x = (px / width) * 2 - 1;
  const y = -(py / height) * 2 + 1;
});
```

### 鼠标选中模型

intersects[0].object 就是选中的第一个模型

```javascript
renderer.domElement.addEventListener('click', function (event) {
    1.坐标转换
    // .offsetY、.offsetX以canvas画布左上角为坐标原点,单位px
    const px = event.offsetX;
    const py = event.offsetY;
    //屏幕坐标px、py转WebGL标准设备坐标x、y
    //width、height表示canvas画布宽高度
    const x = (px / width) * 2 - 1;
    const y = -(py / height) * 2 + 1;

    2.发射射线
    //创建一个射线投射器`Raycaster`
    const raycaster = new THREE.Raycaster();
    //.setFromCamera()计算射线投射器`Raycaster`的射线属性.ray
    // 形象点说就是在点击位置创建一条射线，射线穿过的模型代表选中
    raycaster.setFromCamera(new THREE.Vector2(x, y), camera);

    3.射中要检测的网格模型数组
    //.intersectObjects([mesh1, mesh2, mesh3])对参数中的网格模型对象进行射线交叉计算
    // 未选中对象返回空数组[],选中一个对象，数组1个元素，选中两个对象，数组两个元素
    const intersects = raycaster.intersectObjects([mesh1, mesh2, mesh3]);
    console.log("射线器返回的对象", intersects);
    // intersects.length大于0说明，说明选中了模型
    if (intersects.length > 0) {
        // 选中模型的第一个模型，设置为红色
        intersects[0].object.material.color.set(0xff0000);
    }
})
```

### Canvas 尺寸变化(射线坐标计算)

```javascript
renderer.domElement.addEventListener("click", function (event) {
  const px = event.offsetX;
  const py = event.offsetY;
  //屏幕坐标转WebGL标准设备坐标
  const x = (px / window.innerWidth) * 2 - 1;
  const y = -(py / window.innerHeight) * 2 + 1;
});
```

#### canvas 局部布局

```javascript
renderer.domElement.addEventListener("click", function (event) {
  const width = window.innerWidth - 200;
  const height = window.innerHeight - 60;
  //屏幕坐标转WebGL标准设备坐标
  const x = (px / width) * 2 - 1;
  const y = -(py / height) * 2 + 1;
});
```

### 对象包含多个物体，对象整体发光

父对象的所有子对象 Mesh 自定义一个属性`.ancestors`，然后让该属性指向需要射线拾取父对象。

```javascript
const cunchu = model.getObjectByName("存储罐");
// 射线拾取模型对象(包含多个Mesh)
// 可以给待选对象的所有子孙后代Mesh，设置一个祖先属性ancestors,值指向祖先(待选对象)
for (let i = 0; i < cunchu.children.length; i++) {
  const group = cunchu.children[i];
  //递归遍历chooseObj，并给chooseObj的所有子孙后代设置一个ancestors属性指向自己
  group.traverse(function (obj) {
    if (obj.isMesh) {
      obj.ancestors = group;
    }
  });
}
// 射线交叉计算拾取模型
const intersects = raycaster.intersectObjects(cunchu.children);
console.log("intersects", intersects);
if (intersects.length > 0) {
  // 通过.ancestors属性判断那个模型对象被选中了
  outlinePass.selectedObjects = [intersects[0].object.ancestors];
}
```

### 拾取精灵模型

```javascript
给精灵模型绑定一个函数.change();
sprite.change = function () {
  mesh.material.color.set(0xffffff);
};
sprite2.change = function () {
  mesh.material.color.set(0xffff00);
};
```

```javascript
addEventListener('click', function (event) {
    ...
    ...
    // 射线交叉计算拾取精灵模型
    const intersects = raycaster.intersectObjects([sprite,sprite2]);
    if (intersects.length > 0) {
        intersects[0].object.change();//执行选中sprite绑定的change函数
    }
})
```
