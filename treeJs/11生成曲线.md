### 理解

#### 构建几何体

```js
BufferGeometry//缓冲类型几何体  对象
```

```js
类型化数组 Float32Array //数据格式
```

```javascript
//属性缓冲区对象BufferAttribute
//表示几何体顶点数据 数据 对象
//将类型化数组转换为属性缓冲器对象
const attribue = new THREE.BufferAttribute(vertices, 3); 
```

```javascript
geometry.attributes.position//几何体顶点位置属性
```

threejs中顶点坐标就是类型化数组Float32Array([])

![image-20230816200659752](../../assests/image-20230816200659752.png)



### 绘制圆形

sin 对边比斜边

cos 邻边比斜边

![image-20230725110105907](../../assests/image-20230725110105907.png)

```js
const R = 100; //圆弧半径
const N = 50; //分段数量
// 批量生成圆弧上的顶点数据
const arr = [];
const sp = (2 * Math.PI) / N; //两个相邻点间隔弧度
// const sp = 1 * Math.PI / N;//半圆弧
for (let i = 0; i < N + 1; i++) {
  const angle = sp * i;
  // 以坐标原点为中心，在XOY平面上生成圆弧上的顶点数据
  const x = R * Math.cos(angle);
  const y = R * Math.sin(angle);
  arr.push(x, y, 0);
}
// // 设置圆心坐标
// const cx = 200;
// const cy = 100;
// for (let i = 0; i < N + 1; i++) {
//     const angle = sp * i;//当前点弧度
//     const x = cx + R * Math.sin(angle);
//     const y = cy + R * Math.cos(angle);
//     arr.push(x, y, 0);
// }
//类型数组创建顶点数据
```

### 通过vector3点的位置设置几何体顶点数据

.setFromPoints()通过Vector3-顶点坐标设置`geometry.attributes.position`属性

```js
const pointsArr = [
  // 三维向量Vector3表示的坐标值
  new THREE.Vector3(0, 0, 0),
  new THREE.Vector3(0, 100, 0),
  new THREE.Vector3(0, 100, 100),
  new THREE.Vector3(0, 0, 100),
];

// 把数组pointsArr里面的坐标数据提取出来，赋值给`geometry.attributes.position`属性
geometry.setFromPoints(pointsArr);
console.log("几何体变化", geometry.attributes.position);

// const pointsArr = [
//     // 三维向量Vector2表示的坐标值 在xoy坐标内
//     new THREE.Vector2(0,0),
//     new THREE.Vector2(100,0),
//     new THREE.Vector2(100,100),
//     new THREE.Vector2(0,100),
// ];
```

### 曲线

![img](http://www.webgl3d.cn/imgthreejs/%E6%9B%B2%E7%BA%BF%E7%88%B6%E7%B1%BBCurve.svg)

### 椭圆`EllipseCurve`例子

.getPoints(50)curve的方法，曲线上按细分度返回顶点坐标v3

通过曲线中取点，然后设置几何体顶点属性

```js
// 参数1和2表示椭圆中心坐标  参数3和4表示x和y方向半径
const arc = new THREE.EllipseCurve(0, 0, 100, 50);

//getPoints是基类Curve的方法，平面曲线会返回一个vector2对象作为元素组成的数组 在xoy方向
const pointsArr = arc.getPoints(50); //分段数50，返回51个顶点
// 把数组pointsArr里面的坐标数据提取出来，赋值给`geometry.attributes.position`属性
geometry.setFromPoints(pointsArr);
```

通过`.getSpacedPoints()`和`.getPoints()`一样也可以从曲线 Curve 上返回一系列曲线上的顶点坐标。

`.getPoints()`获取点的方式并`不是`按照曲线`等间距`的方式，而是会考虑曲线斜率变化，斜率变化快的位置返回的顶点更密集。

### 圆弧线`ArcCurve`

可以做多边形

```js
// 参数1和2表示椭圆中心坐标  参数3和4表示x和y方向半径
const arc = new THREE.EllipseCurve(0, 0, 50, 50);
```

```js
// 完整圆弧
const arc = new THREE.ArcCurve(0, 0, 100, 0, 2 * Math.PI);
// 半圆弧
const arc = new THREE.ArcCurve(0, 0, 100, 0, Math.PI);
// 四分之一圆弧
const arc = new THREE.ArcCurve(0, 0, 100, 0, Math.PI / 2);
```

### 三维样条曲线

经过点形成的数组，创建样条曲线，细分样条曲线获得更多的点，赋值给几何体顶点

```js
// 三维向量Vector3创建一组顶点坐标
const arr = [
  new THREE.Vector3(-50, 20, 90),
  new THREE.Vector3(-10, 40, 40),
  new THREE.Vector3(0, 0, 0),
  new THREE.Vector3(60, -60, 0),
  new THREE.Vector3(70, 0, 80),
];
// 三维样条曲线
const curve = new THREE.CatmullRomCurve3(arr);

//曲线上获取点
const pointsArr = curve.getPoints(100); //曲线细分点
const geometry = new THREE.BufferGeometry();
//读取坐标数据赋值给几何体顶点
geometry.setFromPoints(pointsArr);
// 线材质
const material = new THREE.LineBasicMaterial({
  color: 0x00fffff,
});
// 线模型
const line = new THREE.Line(geometry, material);
```

### 二维样条曲线

```js
// 二维向量Vector2创建一组顶点坐标
const arr = [
  new THREE.Vector2(-100, 0),
  new THREE.Vector2(0, 30),
  new THREE.Vector2(100, 0),
];
// 二维样条曲线
const curve = new THREE.SplineCurve(arr);
```

### 贝塞尔曲线

![image-20230725180933426](../../assests/image-20230725180933426.png)

![image-20230725180154921](../../assests/image-20230725180154921.png)

不经过控制点

### 二维贝塞尔

```js
// p1、p2、p3表示三个点坐标
// p1、p3是曲线起始点，p2是曲线的控制点
const p1 = new THREE.Vector2(-80, 0);
const p2 = new THREE.Vector2(20, 100);
const p3 = new THREE.Vector2(80, 0);

// 二维二次贝赛尔曲线
const curve = new THREE.QuadraticBezierCurve(p1, p2, p3);

const pointsArr = curve.getPoints(100); //曲线上获取点
const geometry = new THREE.BufferGeometry();
geometry.setFromPoints(pointsArr); //读取坐标数据赋值给几何体顶点
const material = new THREE.LineBasicMaterial({ color: 0x00fffff });
const line = new THREE.Line(geometry, material);
```

### 三维贝塞尔曲线

```js
// p1、p2、p3表示三个点坐标
const p1 = new THREE.Vector3(-80, 0, 0);
const p2 = new THREE.Vector3(20, 100, 0);
const p3 = new THREE.Vector3(80, 0, 100);
// 三维二次贝赛尔曲线
const curve = new THREE.QuadraticBezierCurve3(p1, p2, p3);
```

### 二维三次贝塞尔曲线`CubicBezierCurve`

二维三次贝塞尔曲线`CubicBezierCurve`与二维二次贝赛尔曲线`QuadraticBezierCurve`区别就是多了一个控制点。

![image-20230725180656410](../../assests/image-20230725180656410.png)

```javascript
// p1、p2、p3、p4表示4个点坐标
// p1、p4是曲线起始点，p2、p3是曲线的控制点
const p1 = new THREE.Vector2(-80, 0);
const p2 = new THREE.Vector2(-40, 50);
const p3 = new THREE.Vector2(50, 50);
const p4 = new THREE.Vector2(80, 0);

// 二维三次贝赛尔曲线
const curve = new THREE.CubicBezierCurve(p1, p2, p3, p4);
```

### 三维三次贝赛尔曲线`CubicBezierCurve3`

三维三次贝赛尔曲线`CubicBezierCurve3`与二维三次贝塞尔曲线`CubicBezierCurve`区别就是多了一个维度，参数是三维向量对象 Vector3。

```javascript
const p1 = new THREE.Vector3(-80, 0, 0);
const p2 = new THREE.Vector3(-40, 50, 0);
const p3 = new THREE.Vector3(50, 50, 0);
const p4 = new THREE.Vector3(80, 0, 100);
// 三维三次贝赛尔曲线
const curve = new THREE.CubicBezierCurve3(p1, p2, p3, p4);
```

### 直线

3D 直线线段`LineCurve3`，参数是表示 x、y、z 坐标的三维向量`Vector3`对象。

```javascript
new THREE.LineCurve3(new THREE.Vector3(), new THREE.Vector3());
```

2D 直线线段`LineCurve`，参数是表示 x、y 坐标的二维向量`Vector2`对象。

```javascript
new THREE.LineCurve(new THREE.Vector2(), new THREE.Vector2());
```

### 组合曲线

```js
const R = 80; //圆弧半径
const H = 200; //直线部分高度
// 直线1
const line1 = new THREE.LineCurve(
  new THREE.Vector2(R, H),
  new THREE.Vector2(R, 0)
);
// 圆弧
const arc = new THREE.ArcCurve(0, 0, R, 0, Math.PI, true);
// 直线2
const line2 = new THREE.LineCurve(
  new THREE.Vector2(-R, 0),
  new THREE.Vector2(-R, H)
);

// CurvePath创建一个组合曲线对象
const CurvePath = new THREE.CurvePath();
//line1, arc, line2拼接出来一个U型轮廓曲线，注意顺序
CurvePath.curves.push(line1, arc, line2);

//组合曲线上获取点
const pointsArr = CurvePath.getPoints(16);
const geometry = new THREE.BufferGeometry();
geometry.setFromPoints(pointsArr); //读取坐标数据赋值给几何体顶点
```

### 管道 TubeGeometry

```js
// 三维样条曲线
const path = new THREE.CatmullRomCurve3([
  new THREE.Vector3(-50, 20, 90),
  new THREE.Vector3(-10, 40, 40),
  new THREE.Vector3(0, 0, 0),
  new THREE.Vector3(60, -60, 0),
  new THREE.Vector3(70, 0, 80),
]);

// path:路径   40：沿着轨迹细分数  2：管道半径   25：管道截面圆细分数
const geometry = new THREE.TubeGeometry(path, 40, 2, 25);
```

### 旋转轮廓-几何体

<img src="../../assests/image-20230725195757386.png" alt="image-20230725195757386" style="zoom:33%;" />

```js
// Vector2表示的三个点坐标，三个点构成的轮廓相当于两端直线相连接
const pointsArr = [
  new THREE.Vector2(50, 60),
  new THREE.Vector2(25, 0),
  new THREE.Vector2(50, -60),
];
// LatheGeometry：pointsArr轮廓绕y轴旋转生成几何体曲面
// pointsArr：旋转几何体的旋转轮廓形状
// 30：旋转圆周方向几何体细分精度
// 0, Math.PI：旋转的开始角度和结束角度
const geometry = new THREE.LatheGeometry(pointsArr, 30, 0, Math.PI);
```

### 轮廓填充 shap

多个三角形拼成的

shap是轮廓

然后通过轮廓设置几何体

```js
// 一组二维向量表示一个多边形轮廓坐标
const pointsArr = [
    new THREE.Vector2(-50, -50),
    new THREE.Vector2(-60, 0),
    new THREE.Vector2(0, 50),
    new THREE.Vector2(60, 0),
    new THREE.Vector2(50, -50),
]

// Shape表示一个平面多边形轮廓,参数是二维向量构成的数组pointsArr
const shape = new THREE.Shape(pointsArr);

把五边形轮廓Shape作为ShapeGeometry的参数，形成一个多边形平面几何体。
ShapeGeometry的参数可以是一个shap，也可以是多个形成的数组[shap1,shap2]
const geometry = new THREE.ShapeGeometry(shape);
```

### 拉伸 ExtrudeGeometry

![img](http://www.webgl3d.cn/imgthreejs/%E6%8B%89%E4%BC%B8%E6%88%90%E5%9E%8B.png)

拉伸成型

```js
// Shape表示一个平面多边形轮廓
const shape = new THREE.Shape([
  // 按照特定顺序，依次书写多边形顶点坐标
  new THREE.Vector2(-50, -50), //多边形起点
  new THREE.Vector2(-50, 50),
  new THREE.Vector2(50, 50),
  new THREE.Vector2(50, -50),
]);
//拉伸造型
const geometry = new THREE.ExtrudeGeometry(
  shape, //二维轮廓
  {
    depth: 20, //拉伸长度
  }
);
```

倒圆角

```javascript
const geometry = new THREE.ExtrudeGeometry(shape, {
  depth: 20, //拉伸长度
  bevelThickness: 5, //倒角尺寸:拉伸大小
  bevelSize: 5, //倒角尺寸:垂直拉伸大小
  bevelSegments: 20, //倒圆角：倒角细分精度，默认3
  bevelEnabled: false, //是否设置倒角,默认true
});
```

倒直角

```javascript
const geometry = new THREE.ExtrudeGeometry(shape, {
  bevelSegments: 1, //倒直角
});
```

### 扫描 ExtrudeGeometry

![img](http://www.webgl3d.cn/imgthreejs/%E6%89%AB%E6%8F%8F%E6%88%90%E5%9E%8B.png)

扫描轮廓

```javascript
// 扫描轮廓：Shape表示一个平面多边形轮廓
const shape = new THREE.Shape([
  // 按照特定顺序，依次书写多边形顶点坐标
  new THREE.Vector2(0, 0), //多边形起点
  new THREE.Vector2(0, 10),
  new THREE.Vector2(10, 10),
  new THREE.Vector2(10, 0),
]);
```

扫描轨迹

```js
// 扫描轨迹：创建轮廓的扫描轨迹(3D样条曲线)
const curve = new THREE.CatmullRomCurve3([
  new THREE.Vector3(-10, -50, -50),
  new THREE.Vector3(10, 0, 0),
  new THREE.Vector3(8, 50, 50),
  new THREE.Vector3(-5, 0, 100),
]);
```

扫描造型

```javascript
//扫描造型：扫描默认没有倒角
const geometry = new THREE.ExtrudeGeometry(
  shape, //扫描轮廓
  {
    extrudePath: curve, //扫描轨迹
    steps: 100, //沿着路径细分精度，越大越光滑，默认是1
  }
);
```

### path

是curve的子类

![img](http://www.webgl3d.cn/imgthreejs/Shape%E7%9A%84%E7%88%B6%E7%B1%BBPath.svg)

#### `.currentPoint`属性

![image-20230816204323267](../../assests/image-20230816204323267.png)

是 path 的属性 path 是 shape 的父类

当前点

```js
const shape = new THREE.Shape();
const path = new THREE.Path();
console.log("currentPoint", shape.currentPoint);
```

`.moveTo()`方法

可以改变 currentPoint 的值

```js
const shape = new THREE.Shape();
shape.moveTo(10, 0); //.currentPoint变为(10,0)
```

#### 绘制直线.lineTo()

path 的方法

结束点是`.lineTo()`的参数表示的坐标

同时改变.currentPoint 的值

```js
const shape = new THREE.Shape();
shape.moveTo(10, 0); //.currentPoint变为(10,0)
// 绘制直线线段，起点(10,0)，结束点(100,0)
shape.lineTo(100, 0);
```

### 绘制拼接 Shape(圆弧)

圆弧`.arc()`参数的圆心坐标是相对当前`.currentPoint`而言,而不是坐标原点

#### 圆弧方法`.arc()`

圆弧方法`.arc()`使用方式和原来学习过的圆弧曲线`ArcCurve`整体相似，区别在于圆心定位方式有差异。

圆弧`.arc()`参数的圆心坐标是相对当前`.currentPoint`而言,而不是坐标原点。

下面代码绘制了一个矩形+扇形的轮廓，圆心在(100, 0),半径 50。

```js
// 下面代码绘制了一个矩形+扇形的轮廓，圆心在(100, 0),半径50。
const shape = new THREE.Shape();
shape.lineTo(100 + 50, 0); //.currentPoint变为(100+50,0)
// 圆弧.arc参数的圆心0,0坐标是相对当前.currentPoint而言，而不是坐标原点
shape.arc(-50, 0, 50, 0, Math.PI / 2); //.currentPoint变为圆弧线结束点坐标
console.log("currentPoint", shape.currentPoint);
// 绘制直线，直线起点：圆弧绘制结束的点  直线结束点：(0, 0)
shape.lineTo(0, 50);
// shape:填充轮廓
const geometry = new THREE.ShapeGeometry(shape, 20);
```

另一种写法：直线和圆弧起点之间的缺口 threejs 内部会自动补上

```js
// 下面代码绘制了一个矩形+扇形的轮廓，圆心在(100, 0),半径50。
const shape = new THREE.Shape();
shape.lineTo(100, 0); //.currentPoint变为(100,0)
// 圆弧.arc参数的圆心0,0坐标是相对当前.currentPoint而言，而不是坐标原点
shape.arc(0, 0, 50, 0, Math.PI / 2); //.currentPoint变为圆弧线结束点坐标
console.log("currentPoint", shape.currentPoint);
// 绘制直线，直线起点：圆弧绘制结束的点  直线结束点：(0, 0)
shape.lineTo(0, 50);
```

### [#](http://www.webgl3d.cn/pages/ccc74f/#绝对圆弧方法-absarc)绝对圆弧方法`.absarc()`

`.absarc()`圆心坐标不受到`.currentPoint`影响，以坐标`原点`作为参考，这一点和圆弧方法`.arc()`不同。

下面代码绘制了一个矩形+扇形的轮廓，圆心在(100, 0),半径 50。

```javascript
const shape = new THREE.Shape();
shape.lineTo(100, 0); //.currentPoint变为(100,0)
// absarc圆心坐标不受到.currentPoint影响，以坐标原点作为参考
shape.absarc(100, 0, 50, 0, Math.PI / 2); //.currentPoint变为圆弧线结束点坐标
console.log("currentPoint", shape.currentPoint);
shape.lineTo(0, 50);
```

### `.holes`设置内孔的轮廓

![img](http://www.webgl3d.cn/imgthreejs/%E5%A4%9A%E8%BE%B9%E5%BD%A2%E5%86%85%E5%AD%94.jpg)

外轮廓

先创建`Shape`的矩形外轮廓。

```javascript
const shape = new THREE.Shape();
// .lineTo(100, 0)绘制直线线段，线段起点：.currentPoint，线段结束点：(100,0)
shape.lineTo(100, 0);
shape.lineTo(100, 100);
shape.lineTo(0, 100);
```

Path 对象创建内部多个轮廓。

```javascript
// Shape内孔轮廓
const path1 = new THREE.Path(); // 圆孔1
path1.absarc(20, 20, 10);
const path2 = new THREE.Path(); // 圆孔2
path2.absarc(80, 20, 10);
const path3 = new THREE.Path(); // 方形孔
path3.moveTo(50, 50);
path3.lineTo(80, 50);
path3.lineTo(80, 80);
path3.lineTo(50, 80);
//三个内孔轮廓分别插入到holes属性中
shape.holes.push(path1, path2, path3);
```

### 模型边线 EdgesGeometry

![img](http://www.webgl3d.cn/imgthreejs/%E6%A8%A1%E5%9E%8B%E8%BE%B9%E7%95%8C%E7%BA%BF%E9%95%BF%E6%96%B9%E4%BD%93.jpg)

用`EdgesGeometry`重新计算长方体几何体，返回一个新的几何体，然后用线模型`LineSegments`模型渲染新的几何体即可。

```js
const geometry = new THREE.BoxGeometry(50, 50, 50);
const material = new THREE.MeshLambertMaterial({
  color: 0x004444,
  transparent: true,
  opacity: 0.5,
});
const mesh = new THREE.Mesh(geometry, material);

// 长方体作为EdgesGeometry参数创建一个新的几何体
const edges = new THREE.EdgesGeometry(geometry);
const edgesMaterial = new THREE.LineBasicMaterial({
  color: 0x00ffff,
});
const line = new THREE.LineSegments(edges, edgesMaterial);
mesh.add(line);
```

![img](http://www.webgl3d.cn/imgthreejs/%E5%9C%86%E6%9F%B1%E6%A8%A1%E5%9E%8B%E8%BE%B9%E7%BA%BF1.jpg)

```js
const geometry = new THREE.CylinderGeometry(60, 60, 100, 30);
const edges = new THREE.EdgesGeometry(geometry);
```

![img](http://www.webgl3d.cn/imgthreejs/%E5%9C%86%E6%9F%B1%E6%A8%A1%E5%9E%8B%E8%BE%B9%E7%BA%BF2.jpg)

EdgesGeometry 第二个参数

仅当相邻面的法线之间的角度（单位为角度）超过这个值时，才会渲染边缘。默认值为 1。

```javascript
const edges = new THREE.EdgesGeometry(geometry, 30);
```

### 外部 gltf 模型设置材质和边线

![img](http://www.webgl3d.cn/imgthreejs/%E6%A8%A1%E5%9E%8B%E8%BE%B9%E7%95%8C%E7%BA%BFgltf.jpg)

```javascript
loader.load("../建筑模型.gltf", function (gltf) {
  // 递归遍历设置每个模型的材质，同时设置每个模型的边线
  gltf.scene.traverse(function (obj) {
    if (obj.isMesh) {
      // 模型材质重新设置
      obj.material = new THREE.MeshLambertMaterial({
        color: 0x004444,
        transparent: true,
        opacity: 0.5,
      });
      // 模型边线设置
      const edges = new THREE.EdgesGeometry(obj.geometry);
      const edgesMaterial = new THREE.LineBasicMaterial({
        color: 0x00ffff,
      });
      const line = new THREE.LineSegments(edges, edgesMaterial);
      obj.add(line);
    }
  });
  model.add(gltf.scene);
});
```

### 改变顶点颜色atributes

vertexColors:true,使用顶点颜色渲染

```js
const geometry = new THREE.BufferGeometry(); //创建一个几何体对象
const vertices = new Float32Array([
  0,
  0,
  0, //顶点1坐标
  50,
  0,
  0, //顶点2坐标
  0,
  25,
  0, //顶点3坐标
]);
// 顶点位置
geometry.attributes.position = new THREE.BufferAttribute(vertices, 3);

const colors = new Float32Array([
  1,
  0,
  0, //顶点1颜色
  0,
  0,
  1, //顶点2颜色
  0,
  1,
  0, //顶点3颜色
]);
// 设置几何体attributes属性的颜色color属性
//3个为一组,表示一个顶点的颜色数据RGB
geometry.attributes.color = new THREE.BufferAttribute(colors, 3);

// 点渲染模式
const material = new THREE.PointsMaterial({
  // color: 0x333333,//使用顶点颜色数据，color属性可以不用设置
  vertexColors: true, //默认false，设置为true表示使用顶点颜色渲染
  size: 20.0, //点对象像素尺寸
});
const points = new THREE.Points(geometry, material); //点模型对象
```

直线渐变颜色

```js
const colors = new Float32Array([
  1,
  0,
  0, //顶点1颜色
  0,
  0,
  1, //顶点2颜色
  0,
  1,
  0, //顶点3颜色
]);
geometry.attributes.color = new THREE.BufferAttribute(colors, 3);

const material = new THREE.LineBasicMaterial({
  vertexColors: true, //使用顶点颜色渲染
});
const line = new THREE.Line(geometry, material);
```

块状渐变

![img](http://www.webgl3d.cn/imgthreejs/%E7%BD%91%E6%A0%BC%E6%A8%A1%E5%9E%8B%E9%A2%9C%E8%89%B2%E6%B8%90%E5%8F%98.jpg)

```javascript
const material = new THREE.MeshBasicMaterial({
  // color: 0x333333,//使用顶点颜色数据，color属性可以不用设置
  vertexColors: true, //默认false，设置为true表示使用顶点颜色渲染
  side: THREE.DoubleSide,
});
const mesh = new THREE.Mesh(geometry, material);
```

### 渐变曲线

蓝色到红色渐变色

```js
const pos = geometry.attributes.position;
const count = pos.count; //顶点数量
// 计算每个顶点的颜色值
const colorsArr = [];
for (let i = 0; i < count; i++) {
  const percent = i / count; //点索引值相对所有点数量的百分比
  //根据顶点位置顺序大小设置颜色渐变
  // 红色分量从0到1变化，蓝色分量从1到0变化
  colorsArr.push(percent, 0, 1 - percent); //蓝色到红色渐变色
}
//类型数组创建顶点颜色color数据
const colors = new Float32Array(colorsArr);
// 设置几何体attributes属性的颜色color属性
geometry.attributes.color = new THREE.BufferAttribute(colors, 3);
```

### 颜色混合

`Color`颜色插值方法`.lerpColors()`

执行`.lerpColors(Color1,Color2, percent)`

percent 表示 Color2 的占比，0-1

```javascript
const c1 = new THREE.Color(0xff0000); //红色
const c2 = new THREE.Color(0x0000ff); //蓝色
const c = new THREE.Color();
c.lerpColors(c1, c2, 0);
(100 % c1) + (0 % c2混合);
```

### 颜色插值方法`.lerp()`

```javascript
const c1 = new THREE.Color(0xff0000); //红色
const c2 = new THREE.Color(0x0000ff); //蓝色
const c = c1.clone().lerp(c2, percent); //颜色插值计算
```

### 插值颜色的应用

两个颜色渐变

```js
// 根据顶点距离起点远近进行颜色插值计算
const c1 = new THREE.Color(0x00ffff); //曲线起点颜色 青色
const c2 = new THREE.Color(0xffff00); //曲线结束点颜色 黄色
for (let i = 0; i < count; i++) {
  const percent = i / count; //点索引值相对所有点数量的百分比
  //根据顶点位置顺序大小设置颜色渐变
  const c = c1.clone().lerp(c2, percent); //颜色插值计算
  colorsArr.push(c.r, c.g, c.b);
}
```

### 获取和设置模型的顶点的分量

```js
const pos = mesh.geometry.attributes.position;
// 获取几何体第一个顶点的x坐标
const x = pos.getX(0); //0是索引
console.log("x", x);
pos.setX(0, 100); //0是索引
```

### 批量设置 y 坐标

```js
loader.load("../地形.glb", function (gltf) {
  model.add(gltf.scene);
  //mesh表示地形网格模型
  const mesh = gltf.scene.children[0];
  // 顶点位置数据
  const pos = mesh.geometry.attributes.position;
  const count = pos.count; //几何体顶点数量
  // 批量设置所有几何体顶点位置的y坐标
  for (let i = 0; i < count; i++) {
    const y = pos.getY(i); //获取第i+1个顶点y坐标
    pos.setY(i, y * 2); //设置第i+1个顶点y坐标为自身2倍
  }
});
```

### 山脉高度可视化

```js
loader.load("../地形.glb", function (gltf) {
  model.add(gltf.scene);
  const mesh = gltf.scene.children[0];
  const pos = mesh.geometry.attributes.position;
  const count = pos.count;

  // 1. 计算模型y坐标高度差
  const yArr = []; //顶点所有y坐标，也就是地形高度
  for (let i = 0; i < count; i++) {
    yArr.push(pos.getY(i)); //获取顶点y坐标，也就是地形高度
  }
  yArr.sort(); //数组元素排序，从小到大
  const miny = yArr[0]; //y最小值
  const maxy = yArr[yArr.length - 1]; //y最大值
  const height = maxy - miny; //山脉整体高度

  // 2. 计算每个顶点的颜色值
  const colorsArr = [];
  const c1 = new THREE.Color(0x0000ff); //山谷颜色
  const c2 = new THREE.Color(0xff0000); //山顶颜色
  for (let i = 0; i < count; i++) {
    //当前高度和整体高度比值
    const percent = (pos.getY(i) - miny) / height;
    const c = c1.clone().lerp(c2, percent); //颜色插值计算
    colorsArr.push(c.r, c.g, c.b);
  }
  const colors = new Float32Array(colorsArr);
  // 设置几何体attributes属性的颜色color属性
  mesh.geometry.attributes.color = new THREE.BufferAttribute(colors, 3);
});

// 3. 设置材质，使用顶点颜色渲染
mesh.material = new THREE.MeshLambertMaterial({
  vertexColors: true,
});
```

### 三种颜色混合

```js
// 2. 计算每个顶点的颜色值
const colorsArr = [];
const color1 = new THREE.Color(0x0000ff); //山谷颜色
const color2 = new THREE.Color(0x00ff00); //山腰颜色
const color3 = new THREE.Color(0xff0000); //山顶颜色
for (let i = 0; i < count; i++) {
  //当前高度和整体高度比值
  const percent = (pos.getY(i) - miny) / height;
  // 颜色插值计算
  let c = null;
  if (percent <= 0.5) {
    //0.5作为颜色插值分界点
    // color1到color2之间插值
    //越到颜色2越接近0.5，
    c = color1.clone().lerp(color2, percent * 2);
  } else {
    // color2到color3之间插值
    c = color2.clone().lerp(color3, (percent - 0.5) * 2);
  }
  colorsArr.push(c.r, c.g, c.b);
}
```
