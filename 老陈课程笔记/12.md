

### 着色器

vec4 必须使用浮点数

![image-20231019111824122](img/image-20231019111824122.png)

```glsl
gl_Position//顶点位置
gl_FragColor//片元着色器的最终颜色值
```

### 模型矩阵

modelMatrix

用于将局部坐标（对象自身的坐标系）变换为世界坐标。它包括对象的位置、旋转和缩放信息

### 视图矩阵

viewMatrix

将3D坐标从模型空间转换到相机空间。它包括相机的位置和朝向，以便将场景正确投影到相机视角,相机的移动缩放、旋转会改变这个矩阵

由相机位置、相机朝向、相机视角决定

### 投影矩阵

projectionMatrix

将物体从三维空间映射到二维屏幕上。

由投影类型（正交投影或透视投影）和投影平面决定

```glsl
gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4( position, 1.0 ) ;
```

### shader插件

![image-20231019161702393](img/image-20231019161702393.png)

### 原始着色器材质RawShaderMaterial

在shaderMaterial中省略的内容

```glsl
precision lowp float;
attribute vec3 color;
attribute vec3 position;//顶点位置
attribute vec2 uv;//uv

uniform mat4 modelMatrix;
uniform mat4 viewMatrix;
uniform mat4 projectionMatrix;
```

### uv

uv的原点在左下角

### ShaderMaterial

可以添加的属性

```js
  wireframe: true,
  side: THREE.DoubleSide,
```

### 飘摇旗案例

着色器材质

![image-20231019173643317](img/image-20231019173643317.png)

传递时间间隔

![image-20231019173823892](img/image-20231019173823892.png)

顶点着色器

![image-20231019174609769](img/image-20231019174609769.png)

片元着色器

![image-20231019175037314](img/image-20231019175037314.png)

### 渐变

左到右，黑到白渐变

![image-20231020114029431](img/image-20231020114029431.png)

下到上，黑到白渐变

![image-20231020114304734](img/image-20231020114304734.png)

渐变反向

![image-20231020114417020](img/image-20231020114417020.png)

取模mod，做多次渐变

0-0.1区间内放大10倍取余就是0-1,也就是一次黑到白的渐变

![image-20231020115039458](img/image-20231020115039458.png)

斑马条纹

step函数

![image-20231020120406377](img/image-20231020120406377.png)

横竖窗户条纹

![image-20231020120706968](img/image-20231020120706968.png)

白色点 条纹相乘

<img src="img/image-20231020120939950.png" alt="image-20231020120939950" style="zoom: 50%;" />

![image-20231020120925125](img/image-20231020120925125.png)

条纹相减 1-0的是白色，其他都是黑色



<img src="img/image-20231020121052619.png" alt="image-20231020121052619" style="zoom:25%;" />

![image-20231020121301702](img/image-20231020121301702.png)

方块条纹 

![image-20231020121457820](img/image-20231020121457820.png)

![image-20231020121519515](img/image-20231020121519515.png)

灰黑灰

![image-20231020122812922](img/image-20231020122812922.png)

![image-20231020122610127](img/image-20231020122610127.png)

十字

![image-20231020150146217](img/image-20231020150146217.png)

![image-20231020151703929](img/image-20231020151703929.png)

<img src="img/image-20231020152003247.png" alt="image-20231020152003247" style="zoom: 50%;" />

```glsl
// 18 取最大值
float strength =max(abs(vUv.x - 0.5), abs(vUv.y - 0.5)) ;
gl_FragColor =vec4(strength,strength,strength,1);
```

<img src="img/image-20231020152323912.png" alt="image-20231020152323912" style="zoom:50%;" />

```glsl
// 19 step
float strength =step(0.2,max(abs(vUv.x - 0.5), abs(vUv.y - 0.5)))   ;
gl_FragColor =vec4(strength,strength,strength,1);
```

<img src="img/image-20231020162244612.png" alt="image-20231020162244612" style="zoom:50%;" />

![image-20231020162226394](img/image-20231020162226394.png)

floor向下取整

<img src="img/image-20231020162734242.png" alt="image-20231020162734242" style="zoom:50%;" />

![image-20231020163043942](img/image-20231020163043942.png)

取整相乘

<img src="img/image-20231020163344601.png" alt="image-20231020163344601" style="zoom:50%;" />

![image-20231020163818770](img/image-20231020163818770.png)

向上取整ceil

```glsl
float strength = ceil(vUv.x*10.0)/10.0*ceil(vUv.y*10.0)/10.0;
    gl_FragColor =vec4(strength,strength,strength,1);
```

https://thebookofshaders.com/10/?lan=ch

随机函数 生成0-1的随机数

<img src="img/image-20231020171313469.png" alt="image-20231020171313469" style="zoom:50%;" />

![image-20231020165750502](img/image-20231020165750502.png)

```glsl
// 随机函数
float random (vec2 st) {
    return fract(sin(dot(st.xy,vec2(12.9898,78.233)))*43758.5453123);
}
```

随机格子

<img src="img/image-20231020171228227.png" alt="image-20231020171228227" style="zoom:50%;" />

```glsl
float strength = ceil(vUv.x*10.0)/10.0*ceil(vUv.y*10.0)/10.0;
    strength = random(vec2(strength,strength));
    gl_FragColor =vec4(strength,strength,strength,1);
```

length

<img src="img/image-20231020171936682.png" alt="image-20231020171936682" style="zoom:50%;" />

![image-20231020171921430](img/image-20231020171921430.png)

distance

<img src="img/image-20231020172215058.png" alt="image-20231020172215058" style="zoom:50%;" />

![image-20231020172203531](img/image-20231020172203531.png)

<img src="img/image-20231020174048995.png" alt="image-20231020174048995" style="zoom:50%;" />

![image-20231020174039202](img/image-20231020174039202.png)



压扁星星

<img src="img/image-20231020175059096.png" alt="image-20231020175059096" style="zoom:50%;" />

```glsl
float strength =0.15 / distance(vec2(vUv.x,(vUv.y-0.5)*5.0),vec2(0.5,0.5)) - 1.0;
    gl_FragColor =vec4(strength,strength,strength,strength);

```

十字星星

![image-20231020175803557](img/image-20231020175803557.png)

![image-20231020175515383](img/image-20231020175515383.png)

旋转函数



```glsl
// 旋转函数
vec2 rotate(vec2 uv, float rotation, vec2 mid)
{
    return vec2(
      cos(rotation) * (uv.x - mid.x) + sin(rotation) * (uv.y - mid.y) + mid.x,
      cos(rotation) * (uv.y - mid.y) - sin(rotation) * (uv.x - mid.x) + mid.y
    );
}
```

![image-20231020180610666](img/image-20231020180610666.png)

圆形

![image-20231020181108869](img/image-20231020181108869.png)

```glsl
 float strength = step(0.5,distance(vUv,vec2(0.5))+0.25) ;
    gl_FragColor =vec4(strength,strength,strength,1);
```

圆形

![image-20231020181207540](img/image-20231020181207540.png)

![image-20231020181222045](img/image-20231020181222045.png)



![image-20231020181501518](img/image-20231020181501518.png)

![image-20231020181449989](img/image-20231020181449989.png)

渐变环

<img src="img/image-20231023113510075.png" alt="image-20231023113510075" style="zoom:50%;" />

![image-20231023113458388](img/image-20231023113458388.png)

<img src="img/image-20231023114045842.png" alt="image-20231023114045842" style="zoom:50%;" />

```glsl
float strength = step(0.1,abs(distance(vUv,vec2(0.5))-0.25));
    gl_FragColor =vec4(strength,strength,strength,1);
```

波浪环

<img src="img/image-20231023115056703.png" alt="image-20231023115056703" style="zoom:50%;" />

```glsl
 vec2 waveUv = vec2(
        vUv.x,
        vUv.y+sin(vUv.x*30.0)*0.1
    );


    float strength = 1.0 - step(0.01,abs(distance(waveUv,vec2(0.5))-0.25))   ;
    gl_FragColor =vec4(strength,strength,strength,1);
```

<img src="img/image-20231023115438034.png" alt="image-20231023115438034" style="zoom:50%;" />

```glsl
vec2 waveUv = vec2(
        vUv.x+sin(vUv.y*30.0)*0.1,
        vUv.y+sin(vUv.x*30.0)*0.1
    );
    float strength = 1.0 - step(0.01,abs(distance(waveUv,vec2(0.5))-0.25))   ;
    gl_FragColor =vec4(strength,strength,strength,1);
```

atan返回的是弧度值

<img src="img/image-20231023160247729.png" alt="image-20231023160247729" style="zoom:50%;" />

![image-20231023160229897](img/image-20231023160229897.png)

<img src="img/image-20231023165831112.png" alt="image-20231023165831112" style="zoom:50%;" />

![image-20231023165738348](img/image-20231023165738348.png)

<img src="img/image-20231023170339706.png" alt="image-20231023170339706" style="zoom:50%;" />

![image-20231023170309811](img/image-20231023170309811.png)



雷达旋转

```glsl
vec2 rotateUv = rotate(vUv,-uTime*5.0,vec2(0.5));
float alpha =  1.0 - step(0.5,distance(vUv,vec2(0.5)));
float angle = atan(rotateUv.x-0.5,rotateUv.y-0.5);
float strength = (angle+3.14)/6.28;
gl_FragColor =vec4(strength,strength,strength,alpha);
```

<img src="img/image-20231023173306713.png" alt="image-20231023173306713" style="zoom:50%;" />

<img src="img/image-20231023173320053.png" alt="image-20231023173320053" style="zoom:150%;" />

定义常量

```glsl
#define PI 3.1415926535897932384626433832795
```

<img src="img/image-20231023174539714.png" alt="image-20231023174539714" style="zoom:50%;" />

![image-20231023174632229](img/image-20231023174632229.png)

噪音函数

<img src="img/image-20231023180410723.png" alt="image-20231023180410723" style="zoom:50%;" />

```glsl
float noise (in vec2 _st) {
    vec2 i = floor(_st);
    vec2 f = fract(_st);

    // Four corners in 2D of a tile
    float a = random(i);
    float b = random(i + vec2(1.0, 0.0));
    float c = random(i + vec2(0.0, 1.0));
    float d = random(i + vec2(1.0, 1.0));

    vec2 u = f * f * (3.0 - 2.0 * f);

    return mix(a, b, u.x) +
            (c - a)* u.y * (1.0 - u.x) +
            (d - b) * u.x * u.y;
}

```

![image-20231023180446096](img/image-20231023180446096.png)

mix混合 0前一个颜色，1后一个颜色

```glsl
vec3 mixColor =  mix(greenColor,purpleColor,1.0);
```

### 孔明灯案例

着色器材质设置

![image-20231024113302532](img/image-20231024113302532.png)

顶点着色器

![image-20231024113625640](img/image-20231024113625640.png)

片元着色器

gl_FrontFacing 判断是正面还是反面

![image-20231024113938854](img/image-20231024113938854.png)